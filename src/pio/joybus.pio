;    Copyright 2023 Zaden Ruggiero-Boun√©
;
;    This file is part of NobGCC-SW.
;
;    NobGCC-SW is free software: you can redistribute it and/or modify it under
;   the terms of the GNU General Public License as published by the Free Software
;   Foundation, either version 3 of the License, or (at your option) any later
;   version.
;
;    NobGCC-SW is distributed in the hope that it will be useful, but WITHOUT ANY
;   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
;   A PARTICULAR PURPOSE. See the GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License along with
;   NobGCC-SW If not, see http://www.gnu.org/licenses/.

.define public TX_SYS_IRQ 0
.define public RX_WAIT_IRQ 1
.define TX_WAIT_IRQ 4

.program joybus_rx

; Handle communication from a Gamecube console to a Gamecube input device
;
; Listens for commands from the console and pushes them into the RX FIFO
;
; SM clock should be 8 MHz
;
; Autopush should be configured with a threshold of 8 bits
;
; The ISR should be configured to shift left
;
; The FIFOs should be joined for RX only
;
; IN/WAIT pin base should be set to data pin
;
; EXECCTRL_JMP_PIN should be set to data pin

.define T1 14
.define T2 16

.wrap_target
read:
  wait 0 pin 0           [T1 - 1] ; Wait for data line to go low, then wait 1.75us
  in pins, 1                      ; Read pin value
  wait 1 pin 0                    ; Wait for data line to go high
.wrap
public read_stop_bit:
  wait 1 pin 0                    ; Wait for data line to go high at end of last bit
  wait 0 pin 0                    ; Wait for data line to go low at start of stop bit
  wait 1 pin 0           [T2 - 1] ; Wait for data line to go high at end of stop bit, then delay 2us for stop bit to finish
  irq nowait TX_WAIT_IRQ          ; Raise TX_WAIT_IRQ to signal to TX SM that stop bit has finished
  irq wait RX_WAIT_IRQ            ; Wait on RX_WAIT_IRQ for TX SM to signal that data transmission has finished
  jmp read                        ; Resume reading

% c-sdk {
#include "hardware/clocks.h"

static inline void joybus_rx_program_init(PIO pio, uint sm, uint offset, uint data_pin) {
  // Get default config
  pio_sm_config c = joybus_rx_program_get_default_config(offset);

  // Set clock divider to run at 8 MHz
  float divider = (float)clock_get_hz(clk_sys) / (8 * MHZ);
  sm_config_set_clkdiv(&c, divider);

  // Set ISR to shift left, autopush with an 8-bit threshold
  sm_config_set_in_shift(&c, false, true, 8);

  // Join TX & RX FIFO for RX only
  sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

  // Configure SM pins
  sm_config_set_in_pins(&c, data_pin);

  // Load configuration
  pio_sm_init(pio, sm, offset, &c);

  // Start the state machine
  pio_sm_set_enabled(pio, sm, true);
}
%}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.program joybus_tx

; Handle communication from a GameCube input device to a GameCube console
;
; Accepts the controller state in 8-bit chunks from the TX FIFO and sends them MSB first over GPIO
;
; Clears RX_WAIT_IRQ flag after sending the controller stop bit to restart the RX state machine
;
; SM clock should be 8 MHz
;
; Autopull should be configured with a threshold of 8 bits
;
; The OSR should be configured to shift left
;
; The FIFOs should be joined for TX only
;
; Data pin should be set to input

.define T1 8
.define T2 6
.define T3 16
.define T4 2

  pull block                      ; Get magic value that won't be pushed in regular transmission
  out x, 32                       ; Fill scratch register X with magic value from OSR
wait_to_transmit:
  irq clear RX_WAIT_IRQ           ; Clear the RX_WAIT IRQ to resume the RX state machine
  irq wait TX_SYS_IRQ             ; Wait for CPU to clear IRQ for output
  wait 1 irq TX_WAIT_IRQ          ; Wait for RX SM to raise IRQ indicating stop bit is done
  set pins, 1                     ; Set pin high
  set pindirs, 1                  ; Set to output
fetch_data:
  pull noblock                    ; Pull if there is more data available
  mov y, osr                      ; Copy OSR contents into scratch register Y
  jmp x!=y send_data              ; If there is more data, continue to transmit
  nop                    [T4 - 1] ; Wait two cycles to let previous bit finish
  set pins, 0            [T3 - 1] ; Drive low for 2us for stop bit
  set pins, 1            [T3 - 1] ; Let high for 2us for stop bit
  set pindirs, 0                  ; Set to input
  jmp wait_to_transmit            ; Stop transmitting
send_data:
  out null, 24                    ; Discard 24 MSBs to get the actual byte left-aligned
  set y, 7                        ; Setup bit counter
send_bit:
  set pins, 0            [T1 - 1] ; Drive low at start of bit
  out pins, 1            [T3 - 1] ; Drive low/let high based on OSR contents
  set pins, 1            [T1 - 8] ; Let high at end of bit
  jmp y-- delay                   ; If this isn't the last bit, delay extra cycles
  jmp fetch_data                  ; If this is the last bit, fetch the next byte
delay:
  jmp send_bit           [T2 - 1] ; Delay to keep timing with the 8 cycles between bytes

% c-sdk {
#include "hardware/clocks.h"

static inline void joybus_tx_program_init(PIO pio, uint sm, uint offset, uint data_pin) {
  // Get default config
  pio_sm_config c = joybus_tx_program_get_default_config(offset);

  // Set SM run at 8MHz
  float divider = (float)clock_get_hz(clk_sys) / (8 * MHZ);
  sm_config_set_clkdiv(&c, divider);

  // Set OSR to shift left, 8-bit threshold
  sm_config_set_out_shift(&c, false, false, 8);

  // Join TX & RX FIFO for TX only
  sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

  // Configure SM pins
  sm_config_set_out_pins(&c, data_pin, 1);
  sm_config_set_set_pins(&c, data_pin, 1);

  // Connect PIO to data pin
  pio_gpio_init(pio, data_pin);
 
  // Load configuration
  pio_sm_init(pio, sm, offset, &c);

  // Start the state machine
  pio_sm_set_enabled(pio, sm, true);
}
%}