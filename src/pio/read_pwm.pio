;    Copyright 2023 Zaden Ruggiero-Boun√©
;
;    This file is part of NobGCC-SW.
;
;    NobGCC-SW is free software: you can redistribute it and/or modify it under
;   the terms of the GNU General Public License as published by the Free Software
;   Foundation, either version 3 of the License, or (at your option) any later
;   version.
;
;    NobGCC-SW is distributed in the hope that it will be useful, but WITHOUT ANY
;   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
;   A PARTICULAR PURPOSE. See the GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License along with
;   NobGCC-SW If not, see http://www.gnu.org/licenses/.

.define public PWM_HIGH_CORRECTION 4
.define public PWM_LOW_CORRECTION 1

.program read_pwm

; Reads PWM inputs
;
; First value pushed to RX FIFO (FIFO[0]) is the `high pulse width count - 3`
; Second value pushed to RX FIFO (FIFO[1]) is the `low pulse width count`
;
; (FIFO[0] + 4) / (FIFO[0] + 4 + FIFO[1] + 1) gives the % duty cycle
;
; DMA should be setup to pull on SM RX FIFO DREQ to avoid FIFO getting backed up
;
; SM clock should be set to system clock
;
; The FIFOs should be joined for RX only
;
; IN/WAIT pin base should be set to whichever pin is connected to the PWM input
;
; EXECCTRL_JMP_PIN should be set to whichever pin is connected to the PWM input

start:
  wait 0 pin 0            ; wait for the pin to go low
  wait 1 pin 0        [5] ; wait for the pin to go high, delay for 5 cycles here so that the first high pulse is off by 8 cycles, as future iterations are
.wrap_target
  mov x, ~null            ; high is 0xFFFFFFFF
  mov y, ~null            ; low is 0xFFFFFFFF
count_high:
  jmp x-- check_high      ; decrement high pulse width counter
  jmp start               ; if the counter hits 0, abort & wait for another pulse to start
check_high:
  jmp pin count_high      ; if pin is still high, continue to count high pulse width
count_low:
  jmp pin send_sample     ; if the pin has gone high again, send the sample and restart counting
  jmp y-- count_low       ; decrement low pulse width counter
  jmp start               ; if the counter hits 0, abort & wait for another pulse to start
send_sample:
  mov isr, ~x             ; move the high pulse width counter into the ISR
  push noblock            ; push the high pulse width counter into the RX FIFO
  mov isr, ~y             ; move the low pulse width counter into the ISR
  push noblock            ; push the low pulse width counter into the RX FIFO
  nop                     ; delay 1 extra cycle so that we are off by an even number of cycles

.wrap

% c-sdk {
static inline void read_pwm_program_init(PIO pio, uint sm, uint offset, uint pwm_pin) {
  // Get default config
  pio_sm_config c = read_pwm_program_get_default_config(offset);

  // Join TX & RX FIFO for RX only
  sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

  // Configure SM pins
  sm_config_set_in_pins(&c, pwm_pin);
  sm_config_set_jmp_pin(&c, pwm_pin);
  pio_sm_set_consecutive_pindirs(pio, sm, pwm_pin, 1, false);
  
  // Load configuration
  pio_sm_init(pio, sm, offset, &c);

  // Start the state machine
  pio_sm_set_enabled(pio, sm, true);
}
%}